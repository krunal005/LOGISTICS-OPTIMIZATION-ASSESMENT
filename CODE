### Code Overview
# This modular code includes key components: data ingestion, predictive modeling, route optimization, API setup, and UI integration.

# Import necessary libraries
import pandas as pd
import numpy as np
from flask import Flask, request, jsonify
from sklearn.ensemble import RandomForestRegressor
from ortools.constraint_solver import pywrapcp, routing_enums_pb2
import requests
import folium
import joblib

### Step 1: Data Collection and Synthetic Dataset
# Create a synthetic dataset for demonstration
def create_synthetic_data():
    data = {
        'distance_m': np.random.randint(500, 50000, 100),
        'traffic_score': np.random.uniform(0.5, 1.5, 100),
        'weather_score': np.random.uniform(0.5, 1.5, 100),
        'delivery_time_minutes': np.random.randint(10, 120, 100),
        'order_time': pd.date_range(start='2023-01-01', periods=100, freq='H'),
        'delivery_time': pd.date_range(start='2023-01-01 01:00:00', periods=100, freq='H')
    }
    df = pd.DataFrame(data)
    df['delivery_time'] = df['order_time'] + pd.to_timedelta(df['delivery_time_minutes'], unit='m')
    df.to_csv('synthetic_delivery_data.csv', index=False)
    return df

### Step 2: Data Preprocessing
# Load delivery transaction data
def preprocess_data(file_path):
    df = pd.read_csv(file_path)
    df['distance_km'] = df['distance_m'] / 1000
    df['time_window'] = pd.to_datetime(df['delivery_time']) - pd.to_datetime(df['order_time'])
    return df

### Step 3: Predictive Modeling
# Train a Random Forest Regressor for delivery time prediction
def train_model(data):
    X = data[['distance_km', 'traffic_score', 'weather_score']]
    y = data['delivery_time_minutes']
    model = RandomForestRegressor()
    model.fit(X, y)
    joblib.dump(model, 'delivery_time_model.pkl')
    return model

### Step 4: Route Optimization
# Define a VRP solver
def optimize_routes(locations, demands, vehicle_capacities):
    manager = pywrapcp.RoutingIndexManager(len(locations), len(vehicle_capacities), 0)
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_index, to_index):
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return int(np.linalg.norm(np.array(locations[from_node]) - np.array(locations[to_node])))

    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC

    solution = routing.SolveWithParameters(search_parameters)
    if not solution:
        return None

    routes = []
    for vehicle_id in range(len(vehicle_capacities)):
        index = routing.Start(vehicle_id)
        route = []
        while not routing.IsEnd(index):
            route.append(manager.IndexToNode(index))
            index = solution.Value(routing.NextVar(index))
        routes.append(route)
    return routes

### Step 5: REST API Backend
app = Flask(__name__)

@app.route('/predict', methods=['POST'])
def predict():
    data = request.get_json()
    model = joblib.load('delivery_time_model.pkl')
    features = np.array([data['distance_km'], data['traffic_score'], data['weather_score']]).reshape(1, -1)
    prediction = model.predict(features)
    return jsonify({'predicted_delivery_time': prediction[0]})

@app.route('/routes', methods=['POST'])
def get_routes():
    data = request.get_json()
    locations = data['locations']
    demands = data['demands']
    vehicle_capacities = data['vehicle_capacities']
    routes = optimize_routes(locations, demands, vehicle_capacities)
    return jsonify({'routes': routes})

if __name__ == '__main__':
    # Generate synthetic data for demonstration
    create_synthetic_data()
    # Preprocess the data
    data = preprocess_data('synthetic_delivery_data.csv')
    # Train and save the model
    train_model(data)
    # Run the Flask app
    app.run(debug=True)

### Step 6: UI and Dashboard
# Simple Folium map visualization
locations = [[37.7749, -122.4194], [37.7749, -122.5194], [37.6849, -122.4194]]
map = folium.Map(location=[37.7749, -122.4194], zoom_start=12)
for loc in locations:
    folium.Marker(location=loc).add_to(map)
map.save("dashboard_map.html")
